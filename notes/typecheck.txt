inferring type arguments based on arguments can be done later
  when done, more function types can be subtypes of other function types

what about capabilities for typeargs?
to allow any cap:
  it could be tag, so can't read or write
  it could be mut, so can't send
  it could be iso, so can't alias as our own type
if we want to read
  can't be tag
if we want to write
  can't be imm, box, tag
if we want to send
  can't be trn, mut, box
could specify a set of capabilities?
  A: Foo {iso, tag}
simpler: just make it a subtype relationship
  then type check the class again with the typeargs
  mark methods that don't typecheck with those typeargs as unavailable
  can use this to supply some functions only when certain conditions are met

implicit recover?
  for any expression that accesses only sendable identifiers

expression typing
  atom
    * THIS
    * INT
    * FLOAT
    * STRING
    ? REFERENCE locals
    * TUPLE
    - ARRAY
    - OBJECT
  postfix
    ? DOT field/method access
    - QUALIFY
    ? CALL args, infer type params, ctor and behaviour return types, error
  unop
    * NOT
    * MINUS
    - CONSUME
    - RECOVER
  local
    - VAR/LET
    - AS
    - FOR
  control
    * IF
    - MATCH
    - CASE
    * WHILE
    * REPEAT
    - FOR (or is it sugar?)
    - TRY
    * BREAK
    * CONTINUE
    * RETURN
  binop
    * AND
    * OR
    * XOR
    * PLUS
    * MINUS
    * MULTIPLY
    * DIVIDE
    * MOD
    * LSHIFT
    * RSHIFT
    * IS
    * ISNT
    ? EQ comparable
    ? NE comparable
    ? LT ordered
    ? LE ordered
    ? GE ordered
    ? GT ordered
    ? ASSIGN viewpoint, infer lvalue type, ssa reassignment
  * seq
